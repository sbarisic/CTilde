using CTilde.Expr;
using CTilde.FishAsm;
using System;
using System.CodeDom;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.ComTypes;
using System.Text;
using System.Threading.Tasks;
using System.Xml.Linq;

namespace CTilde.Langs
{
	public class FishAsmProvider : LangProvider
	{
		//bool OmmitSemicolon = false;
		FishCompileState State;

		public FishAsmProvider(FishCompileState State)
		{
			this.State = State;

			EmitRaw("# Generated by C~");
			EmitRaw("# Labels generate in the bytecode bin as the show up in the code, adjecent labels share address by design");
			EmitRaw("# int_table address is set by the VM when the program runs");
		}

		string FormatArgs(object[] args)
		{
			string[] argsStr = new string[args.Length];

			for (int i = 0; i < args.Length; i++)
			{
				if (args[i] is Reg R)
				{
					argsStr[i] = FishUtils.RegToString(R);
				}
				else if (args[i] is uint UI)
				{
					argsStr[i] = string.Format("${0}", UI);
				}
				else
				{
					argsStr[i] = args[i].ToString();
				}
			}

			return string.Join(", ", argsStr);
		}

		const bool SkipDuplicates = true;
		FishInst LastInst;
		object[] LastArgs;
		FishInst[] AllowSkip = new FishInst[] { FishInst.MOVE_REG_OFFSET_REG };

		void EmitInstruction(FishInst inst, params object[] args)
		{
			if (SkipDuplicates)
			{
				if (inst == LastInst && args.Length == LastArgs.Length && args.SequenceEqual(LastArgs) && AllowSkip.Contains(inst))
				{
					//EmitRawUnindented("# Skipping duplicate instruction {0} {1}", inst, FormatArgs(args));
					return;
				}

				LastInst = inst;
				LastArgs = args;
			}

			//Indent();
			AppendLine("{0} {1}", inst, FormatArgs(args));
			//Unindent();
		}

		void EmitRaw(string raw)
		{
			AppendLine(raw);
		}

		void EmitRaw(string fmt, params object[] args)
		{
			EmitRaw(string.Format(fmt, args));
		}

		void EmitRawUnindented(string fmt, params object[] args)
		{
			bool Unindented = false;
			if (Unindent())
				Unindented = true;

			EmitRaw(string.Format(fmt, args));

			if (Unindented)
				Indent();
		}

		void EmitLabels()
		{
			FishLabel[] Lbls = State.GetNewLabels();

			foreach (FishLabel L in Lbls)
			{
				EmitRaw(L.Name + ":");
				Indent();

				if (L.Value.StartsWith("\"") && L.Value.EndsWith("\""))
				{
					EmitRaw(".String {0}", L.Value);
				}
				else
				{
					EmitRaw(".long {0}", L.Value);
				}

				Unindent();
			}
		}

		void EmitReturn()
		{
			EmitInstruction(FishInst.LEAVE);
			EmitInstruction(FishInst.RET);
		}

		void EmitLoadFromAddress(int size, int offset, Reg SrcAddr, Reg DstReg, bool isunsigned)
		{
			if (size == 0)
			{
				EmitInstruction(FishInst.LEA_OFFSET_REG_REG, offset, SrcAddr, DstReg);
			}
			else if (size == 4)
			{
				EmitInstruction(FishInst.MOVE_OFFSET_REG_REG, offset, SrcAddr, DstReg);

			}
			else if (size == 2)
			{
				if (DstReg == Reg.EAX)
				{
					EmitInstruction(FishInst.MOVEBYTE_OFFSET_REG_REG, offset, SrcAddr, Reg.AL);
					EmitInstruction(FishInst.MOVEBYTE_OFFSET_REG_REG, offset + 1, SrcAddr, Reg.AH);
				}
				else if (DstReg == Reg.EBX)
				{
					EmitInstruction(FishInst.MOVEBYTE_OFFSET_REG_REG, offset, SrcAddr, Reg.BL);
					EmitInstruction(FishInst.MOVEBYTE_OFFSET_REG_REG, offset + 1, SrcAddr, Reg.BH);
				}
				else
					throw new NotImplementedException();
			}
			else if (size == 1)
			{
				if (isunsigned)
					EmitInstruction(FishInst.MOVEBYTE_OFFSET_REG_REG, offset, SrcAddr, DstReg);
				else
					EmitInstruction(FishInst.MOVES_OFFSET_REG_REG, offset, SrcAddr, DstReg);
			}
			else
				throw new NotImplementedException();
		}

		void EmitStoreToAddress(int size, int offset, Reg SrcReg, Reg DstAddr, bool isunsigned)
		{
			if (size == 4)
			{
				EmitInstruction(FishInst.MOVE_REG_OFFSET_REG, SrcReg, offset, DstAddr);
			}
			else if (size == 2)
			{
				if (SrcReg == Reg.EAX)
				{
					EmitInstruction(FishInst.MOVEBYTE_REG_OFFSET_REG, Reg.AL, offset, DstAddr);
					EmitInstruction(FishInst.MOVEBYTE_REG_OFFSET_REG, Reg.AH, offset + 1, DstAddr);
				}
				else if (SrcReg == Reg.EBX)
				{
					EmitInstruction(FishInst.MOVEBYTE_REG_OFFSET_REG, Reg.BL, offset, DstAddr);
					EmitInstruction(FishInst.MOVEBYTE_REG_OFFSET_REG, Reg.BH, offset + 1, DstAddr);
				}
				else
					throw new NotImplementedException();
			}
			else if (size == 1)
			{
				EmitInstruction(FishInst.MOVEBYTE_REG_OFFSET_REG, SrcReg, offset, DstAddr);
			}
			else
				throw new NotImplementedException();
		}

		void FetchIdentifier(string name, int size, bool ispointer, Reg DestReg, bool isunsigned, bool sumEBX)
		{
			if (State.IsVarGlobal(name))
			{

				if (size != 0)
				{
					EmitInstruction(FishInst.MOVE_LONG_REG, name, Reg.EBX);
					EmitLoadFromAddress(size, 0, Reg.EBX, DestReg, isunsigned);
				}
				else
				{
					EmitInstruction(FishInst.ADD_LONG_REG, name, DestReg); // NOP to prevent skipping
				}
			}
			else
			{
				int VarOffset = State.GetVarOffset(name);
				// EAX = [EBP+offset]
				EmitInstruction(FishInst.LEA_OFFSET_REG_REG, VarOffset, Reg.EBP, DestReg);

				if (sumEBX)
					EmitInstruction(FishInst.ADD_REG_REG, Reg.EBX, DestReg);

				if (size != 0)
				{
					EmitLoadFromAddress(size, 0, DestReg, DestReg, isunsigned);
				}
				//EmitLoadFromAddress(size, VarOffset, Reg.EBP, DestReg);
			}
		}

		void StoreIdentifier(string name, int size, bool ispointer, Reg SrcReg, bool isunsigned)
		{
			if (State.IsVarGlobal(name))
			{
				EmitInstruction(FishInst.MOVE_LONG_REG, name, Reg.EBX);
				EmitStoreToAddress(size, 0, SrcReg, Reg.EBX, isunsigned);
			}
			else
			{
				int VarOffset = State.GetVarOffset(name);
				EmitStoreToAddress(size, VarOffset, SrcReg, Reg.EBP, isunsigned);
			}
		}

		void StoreIdentifier(string name, int size, bool ispointer, Reg SrcReg, Reg DstAddr, bool isunsigned)
		{
			if (State.IsVarGlobal(name))
			{
				EmitStoreToAddress(size, 0, SrcReg, DstAddr, isunsigned);
			}
			else
			{
				int VarOffset = State.GetVarOffset(name);
				EmitStoreToAddress(size, VarOffset, SrcReg, Reg.EBP, isunsigned);
			}
		}

		public override void Compile(Expression Ex)
		{
			if (Ex == null)
				throw new ArgumentNullException(nameof(Ex));

			switch (Ex)
			{
				case Expr_Block Block:
					{
						foreach (var E in Block.Expressions)
						{
							Compile(E);
						}
						break;
					}

				case Expr_ClassDef ClassDef:
					{
						AppendLine("typedef struct {");

						foreach (var E in ClassDef.Variables)
						{
							Compile(E);
						}

						AppendLine("}} {0};", ClassDef.Name);

						foreach (var F in ClassDef.Functions)
						{
							Compile(F);
						}
						break;
					}

				case Expr_FuncDef FuncDef:
					{
						// Interrupt handler wrapper generation:
						// If a function name starts with "handler_", emit an interrupt-safe stub that saves/restores registers,
						// forwards args, and calls the real implementation (FuncName + "__impl").
						if (FuncDef.FuncName != null && FuncDef.FuncName.StartsWith("handler_"))
						{
							string implName = FuncDef.FuncName + "__impl";

							// Generate the real implementation first under implName
							EmitRaw(".globl {0}", implName);
							State.DefineLabel(implName, true);

							if (FuncDef.FuncBody != null)
							{
								State.ClearVarOffsets();
								State.ClearArgOffset();

								EmitRaw("{0}:", implName);
								Indent();
								State.IsInsideFunctionDef = true;

								if (!FuncDef.Naked)
								{
									EmitInstruction(FishInst.PUSH_REG, Reg.EBP);
									EmitInstruction(FishInst.MOVE_REG_REG, Reg.ESP, Reg.EBP);
								}

								Compile(FuncDef.FuncParams);

								State.IsInsideFunctionDef = false;
								State.IsInsideFunctionBody = true;

								Compile(FuncDef.FuncBody);

								if (!FuncDef.Naked)
								{
									EmitReturn();
								}
								State.IsInsideFunctionBody = false;
								Unindent();
							}

							// Generate the stub at the original name (what int_table[] points to)
							EmitRaw(".globl {0}", FuncDef.FuncName);
							State.DefineLabel(FuncDef.FuncName, true);
							EmitRaw("{0}:", FuncDef.FuncName);
							Indent();

							// Standard prologue
							EmitInstruction(FishInst.PUSH_REG, Reg.EBP);
							EmitInstruction(FishInst.MOVE_REG_REG, Reg.ESP, Reg.EBP);

							// Save registers potentially clobbered by the handler body/calls
							Reg[] saveRegs = new[] { Reg.EAX, Reg.EBX, Reg.ECX, Reg.EDX, Reg.ESI, Reg.EDI };
							foreach (var r in saveRegs)
								EmitInstruction(FishInst.PUSH_REG, r);

							// Forward arguments
							int argCount = FuncDef.FuncParams != null ? FuncDef.FuncParams.Definitions.Count : 0;
							/**if (argCount == 1)
							{
								// VM passes the event payload in XR1; use that as the single arg
								EmitInstruction(FishInst.MOVE_REG_REG, Reg.XR1, Reg.EAX);
								EmitInstruction(FishInst.PUSH_REG, Reg.EAX);
							}
							else if (argCount > 1)**/
							{
								// Fallback: load args from the VM-provided frame (least reliable path)
								for (int i = 0; i < argCount; i++)
								{
									EmitInstruction(FishInst.MOVE_OFFSET_REG_REG, (8 + i * 4), Reg.EBP, Reg.EAX);
									EmitInstruction(FishInst.PUSH_REG, Reg.EAX);
								}
							}

							// Call the real implementation
							EmitInstruction(FishInst.MOVE_LONG_REG, implName, Reg.EAX);
							EmitInstruction(FishInst.CALL_REG, Reg.EAX);

							// Clean up pushed arguments
							if (argCount > 0)
								EmitInstruction(FishInst.ADD_LONG_REG, (uint)(argCount * 4), Reg.ESP);

							// Restore registers (reverse order)
							for (int i = saveRegs.Length - 1; i >= 0; i--)
								EmitInstruction(FishInst.POP_REG, saveRegs[i]);

							// Epilogue
							EmitInstruction(FishInst.LEAVE);
							EmitInstruction(FishInst.RET);

							Unindent();
							break; // done
						}

						// Normal function generation (unchanged)
						EmitRaw(".globl {0}", FuncDef.FuncName);
						State.DefineLabel(FuncDef.FuncName, true);

						if (FuncDef.FuncBody != null)
						{
							State.ClearVarOffsets();
							State.ClearArgOffset();

							EmitRaw("{0}:", FuncDef.FuncName);
							Indent();
							State.IsInsideFunctionDef = true;

							if (!FuncDef.Naked)
							{
								EmitInstruction(FishInst.PUSH_REG, Reg.EBP);
								EmitInstruction(FishInst.MOVE_REG_REG, Reg.ESP, Reg.EBP);
							}

							Compile(FuncDef.FuncParams);

							State.IsInsideFunctionDef = false;
							State.IsInsideFunctionBody = true;

							Compile(FuncDef.FuncBody);

							if (!FuncDef.Naked)
							{
								EmitReturn();
							}
							State.IsInsideFunctionBody = false;
							Unindent();
						}
						break;
					}

				case Expr_Module Module:
					{
						foreach (var E in Module.Expressions)
							Compile(E);

						EmitLabels();
						break;
					}

				case Expr_ParamsDef ParamsDef:
					{
						for (int i = 0; i < ParamsDef.Definitions.Count; i++)
						{
							ParamDefData ParamDef = ParamsDef.Definitions[i];
							int Size = State.GetTypeSize(ParamDef.ParamType);
							State.DefineVar(ParamDef.Name, Size, true, ParamDef.ParamType, false, true);
						}

						break;
					}

				case Expr_TypeDef TypeDef:
					{
						string T = TypeDef.Type;

						if (TypeDef.IsPointer)
							T += "*";
						else if (TypeDef.IsArray)
							T += "[]";

						Append(T);
						break;
					}

				case Expr_StaticValue StaticValueExpr:
					{
						string StatVar = State.DefineFreeLabel("STATVAR", false);
						EmitRaw("{0}:", StatVar);

						if (StaticValueExpr.TypeDefExpr.Type == "string" && StaticValueExpr.TypeDefExpr.IsArray)
						{
							EmitRaw(".Raw {0}, {1}", StaticValueExpr.TypeDefExpr.ArraySize, 0);
						}

						break;
					}

				case Expr_VariableDef VariableDef:
					{
						EmitRaw("# VariableDef BEGIN - {0}", VariableDef.Ident.Identifier);
						Indent();

						if (!State.IsInsideFunctionBody)
						{
							State.DefineLabel(VariableDef.Ident.Identifier, true);
							EmitRaw(".globl {0}", VariableDef.Ident.Identifier);

							int Size = State.GetTypeSize(VariableDef.Type);
							State.DefineVar(VariableDef.Ident.Identifier, Size, false, VariableDef.Type, true, false);
						}
						else
						{
							int Size = State.GetTypeSize(VariableDef.Type);
							State.DefineVar(VariableDef.Ident.Identifier, Size, false, VariableDef.Type, false, false);

							EmitInstruction(FishInst.SUB_LONG_REG, (uint)Size, Reg.ESP);
						}

						Unindent();
						EmitRaw("# VariableDef END - {0}", VariableDef.Ident.Identifier);
						break;
					}

				case Expr_AssignedVariableDef AssVariableDef:
					{
						EmitRaw("# VariableDef BEGIN - {0}", AssVariableDef.VariableDef.Ident.Identifier);
						Indent();

						int Size = State.GetTypeSize(AssVariableDef.VariableDef.Type);
						bool Global = State.IsInsideFunctionBody ? false : true;

						State.DefineVar(AssVariableDef.VariableDef.Ident.Identifier, Size, false, AssVariableDef.VariableDef.Type, Global, false);

						if (State.IsInsideFunctionBody)
						{
							EmitInstruction(FishInst.SUB_LONG_REG, (uint)Size, Reg.ESP);
						}
						else
						{
							State.DefineLabel(AssVariableDef.VariableDef.Ident.Identifier, true);
							EmitRaw(".globl {0}", AssVariableDef.VariableDef.Ident.Identifier);
							EmitRaw("{0}:", AssVariableDef.VariableDef.Ident.Identifier);
						}

						Unindent();
						EmitRaw("# VariableDef END - {0}", AssVariableDef.VariableDef.Ident.Identifier);

						EmitRaw("# VariableAssign BEGIN");
						Indent();

						Compile(AssVariableDef.AssignmentValue);

						if (State.IsInsideFunctionBody)
						{
							int VarID = State.GetVarOffset(AssVariableDef.VariableDef.Ident.Identifier);
							EmitInstruction(FishInst.MOVE_REG_OFFSET_REG, Reg.EAX, VarID, Reg.EBP);
						}

						Unindent();
						EmitRaw("# VariableAssign END");
						break;
					}

				case Expr_AssignValue AssValue:
					{
						if (AssValue.LExpr is Expr_IndexOp IndexOp)
						{
							EmitRaw("# Expr_AssignValue BEGIN");
							Indent();

							State.IndexEmitOnlyAddress = true;
							Compile(AssValue.LExpr);
							State.IndexEmitOnlyAddress = true;

							EmitInstruction(FishInst.MOVE_REG_REG, Reg.EAX, Reg.EBX);

							Compile(AssValue.ValueExpr);
							int CopyBytes = 0;

							if (IndexOp.LExpr is Expr_Identifier Id)
							{
								Expr_TypeDef VarType = State.GetVarType(Id.Identifier);
								CopyBytes = State.GetPointerTypeSize(VarType);

								//EmitStoreToAddress(CopyBytes, 0, Reg.EAX, Reg.EBX, State.IsUnsigned(VarType.Type));
								StoreIdentifier(Id.Identifier, CopyBytes, VarType.IsPointer, Reg.EAX, Reg.EBX, State.IsUnsigned(VarType.Type));

								//StoreIdentifier(Id.Identifier, CopyBytes, VarType.IsPointer, Reg.EAX, State.IsUnsigned(VarType.Type));

								/*if (CopyBytes == 1)
									EmitInstruction(FishInst.MOVEBYTE_REG_OFFSET_REG, Reg.EAX, 0, Reg.EBX);
								else if (CopyBytes == 2)
								{
									EmitInstruction(FishInst.MOVEBYTE_REG_OFFSET_REG, Reg.AL, 0, Reg.EBX);
									EmitInstruction(FishInst.MOVEBYTE_REG_OFFSET_REG, Reg.AH, 1, Reg.EBX);
								}
								else if (CopyBytes == 4)
									EmitInstruction(FishInst.MOVE_REG_OFFSET_REG, Reg.EAX, 0, Reg.EBX);
								else
									throw new NotImplementedException();*/
							}
							else
								throw new NotImplementedException();

							//if (CopyBytes == 4)
							//	EmitInstruction(FishInst.MOVE_REG_OFFSET_REG, Reg.EAX, 0, Reg.EBX);

							Unindent();
							EmitRaw("# Expr_AssignValue END");
						}
						else
							throw new NotImplementedException();

						break;
					}

				case Expr_AssignVariable AssVariable:
					{
						Compile(AssVariable.AssignmentValue);

						//int VarID = State.GetVarOffset(AssVariable.Variable.Identifier);
						//EmitInstruction(FishInst.MOVE_REG_OFFSET_REG, Reg.EAX, VarID, Reg.EBP);
						Expr_TypeDef td = State.GetVarType(AssVariable.Variable.Identifier);
						int sz = State.GetTypeSize(td);

						EmitRaw("# Expr_AssignValue BEGIN");
						Indent();
						StoreIdentifier(AssVariable.Variable.Identifier, sz, td.IsPointer, Reg.EAX, State.IsUnsigned(td.Type));
						Unindent();
						EmitRaw("# Expr_AssignValue END");

						break;
					}

				case Expr_Identifier IdentifierEx:
					{
						Expr_TypeDef IdType = State.GetVarType(IdentifierEx.Identifier);
						int sz = 0;
						bool ispointer = IdType.IsPointer || IdType.IsArray;

						if (ispointer)
							sz = State.GetPointerTypeSize(IdType);
						else
							sz = State.GetTypeSize(IdType);

						//if (State.IsVarGlobal(IdentifierEx.Identifier))
						//{
						// EmitInstruction(FishInst.MOVE_LONG_REG, IdentifierEx.Identifier, Reg.EAX);
						FetchIdentifier(IdentifierEx.Identifier, sz, IdType.IsPointer, Reg.EAX, true, false);
						//}
						//else
						//{
						//	int VarOffset = State.GetVarOffset(IdentifierEx.Identifier);
						//EmitInstruction(FishInst.MOVE_OFFSET_REG_REG, VarOffset, Reg.EBP, Reg.EAX);
						//	FetchIdentifier(IdentifierEx.Identifier, VarOffset, IdType.IsPointer, Reg.EAX);
						//}
						break;
					}

				case Expr_ConstNumber NumberEx:
					{
						uint Num = uint.Parse(NumberEx.NumberLiteral);

						if (State.IsInsideFunctionBody)
						{
							EmitInstruction(FishInst.MOVE_LONG_REG, Num, Reg.EAX);
						}
						else
							EmitRaw(".long {0}", Num);

						break;
					}

				case Expr_ConstString StringEx:
					{
						string LblName = State.DefineLabel(null, StringEx.StringLiteral);

						EmitInstruction(FishInst.MOVE_LONG_REG, LblName, Reg.EAX);
						break;
					}

				case Expr_ConstChar CharEx:
					{
						EmitInstruction(FishInst.MOVES_LONG_REG, (uint)CharEx.CharLiteral, Reg.EAX);
						break;
					}

				case Expr_MathOp MathExp:
					{
						EmitRaw("# MathOp BEGIN ({0})", MathExp.OpString);
						Indent();
						EmitInstruction(FishInst.PUSH_REG, Reg.EBX);

						Compile(MathExp.LExpr);

						EmitInstruction(FishInst.MOVE_REG_REG, Reg.EAX, Reg.EBX);

						Compile(MathExp.RExpr);

						switch (MathExp.Op)
						{
							case MathOperation.Add:
								EmitInstruction(FishInst.ADD_REG_REG, Reg.EBX, Reg.EAX);
								break;

							case MathOperation.Sub:
								EmitInstruction(FishInst.SUB_REG_REG, Reg.EBX, Reg.EAX);
								break;

							default:
								throw new NotImplementedException();
						}

						EmitInstruction(FishInst.POP_REG, Reg.EBX);
						Unindent();
						EmitRaw("# MathOp END ({0})", MathExp.OpString);

						break;
					}

				case Expr_ComparisonOp CompExpr:
					{
						Compile(CompExpr.LExpr);
						EmitInstruction(FishInst.MOVE_REG_REG, Reg.EAX, Reg.EBX);
						Compile(CompExpr.RExpr);

						EmitInstruction(FishInst.CMP_REG_REG, Reg.EAX, Reg.EBX);
						break;
					}

				case Expr_IfElseStatement IfExpr:
					{
						EmitRaw("# If BEGIN");
						Indent();

						string EndLblName = State.DefineFreeLabel("ENDIF", false);
						string ElseLblName = EndLblName;

						if (IfExpr.ElseBody != null)
							ElseLblName = State.DefineFreeLabel("ELSE", false);

						Compile(IfExpr.ConditionValue);

						if (IfExpr.ConditionValue is Expr_ComparisonOp Cmp)
						{
							if (Cmp.Op == ComparisonOp.Equals)
							{
								EmitInstruction(FishInst.JUMP_IF_NOT_ZERO_LONG, ElseLblName);
							}
							else if (Cmp.Op == ComparisonOp.NotEquals)
							{
								EmitInstruction(FishInst.JUMP_IF_ZERO_LONG, ElseLblName);
							}
							else if (Cmp.Op == ComparisonOp.GreaterThan)
							{
								EmitInstruction(FishInst.JUMP_IF_LESSEQ_LONG, ElseLblName);
							}
							else if (Cmp.Op == ComparisonOp.LessThan)
							{
								EmitInstruction(FishInst.JUMP_IF_GREATEQ_LONG, ElseLblName);
							}
							else if (Cmp.Op == ComparisonOp.GreaterThanOrEqual)
							{
								EmitInstruction(FishInst.JUMP_IF_LESS_LONG, ElseLblName);
							}
							else if (Cmp.Op == ComparisonOp.LessThanOrEqual)
							{
								EmitInstruction(FishInst.JUMP_IF_GREAT_LONG, ElseLblName);
							}
							else
								throw new NotImplementedException();
						}
						else
						{
							throw new NotImplementedException();
						}

						State.PushBreakLabel(EndLblName);
						Compile(IfExpr.Body);
						State.PopBreakLabel();

						if (IfExpr.ElseBody != null)
						{
							EmitInstruction(FishInst.JUMP_LONG, EndLblName);
							Unindent();
							EmitRaw("# Else BEGIN");
							Indent();
							EmitRaw("{0}:", ElseLblName);

							State.PushBreakLabel(EndLblName);
							Compile(IfExpr.ElseBody);
							State.PopBreakLabel();

							Unindent();
							EmitRaw("# Else END");
							Indent();
						}

						EmitRaw("{0}:", EndLblName);

						Unindent();
						EmitRaw("# If END");
						break;
					}

				case Expr_WhileStatement WhileExpr:
					{
						EmitRaw("# While BEGIN");
						Indent();

						string LblName = State.DefineFreeLabel("WHILE", false);
						string EndLblName = State.DefineFreeLabel("ENDWHILE", false);
						EmitRaw("{0}:", LblName);
						State.PushLoopLabel(LblName);

						if (WhileExpr.ConditionValue is Expr_ComparisonOp Cmp)
						{
							if (Cmp.Op == ComparisonOp.Equals)
							{
								Compile(WhileExpr.ConditionValue);
								EmitInstruction(FishInst.JUMP_IF_NOT_ZERO_LONG, EndLblName);
							}
							else if (Cmp.Op == ComparisonOp.NotEquals)
							{
								Compile(WhileExpr.ConditionValue);
								EmitInstruction(FishInst.JUMP_IF_ZERO_LONG, EndLblName);
							}
							else if (Cmp.Op == ComparisonOp.LessThan)
							{
								Compile(WhileExpr.ConditionValue);
								EmitInstruction(FishInst.JUMP_IF_LESS_LONG, EndLblName);
							}
							else if (Cmp.Op == ComparisonOp.GreaterThan)
							{
								Compile(WhileExpr.ConditionValue);
								EmitInstruction(FishInst.JUMP_IF_GREAT_LONG, EndLblName);
							}
							else if (Cmp.Op == ComparisonOp.LessThanOrEqual)
							{
								Compile(WhileExpr.ConditionValue);
								EmitInstruction(FishInst.JUMP_IF_LESSEQ_LONG, EndLblName);
							}
							else if (Cmp.Op == ComparisonOp.GreaterThanOrEqual)
							{
								Compile(WhileExpr.ConditionValue);
								EmitInstruction(FishInst.JUMP_IF_GREATEQ_LONG, EndLblName);
							}
							else
								throw new NotImplementedException();

						}
						else if (WhileExpr.ConditionValue is Expr_ConstNumber CNum)
						{
							if (CNum.NumberLiteral == "1")
							{
								EmitInstruction(FishInst.NOP);
							}
							else
								throw new NotImplementedException();
						}
						else
							throw new NotImplementedException();

						State.PushBreakLabel(EndLblName);

						if (WhileExpr.Body.Expressions.Count > 0)
						{
							EmitInstruction(FishInst.PUSH_REG, Reg.EBX);
							EmitInstruction(FishInst.PUSH_REG, Reg.EAX);
							Compile(WhileExpr.Body);
							EmitInstruction(FishInst.POP_REG, Reg.EAX);
							EmitInstruction(FishInst.POP_REG, Reg.EBX);
						}

						State.PopBreakLabel();
						State.PopLoopLabel();

						EmitInstruction(FishInst.JUMP_LONG, LblName);
						EmitRaw("{0}:", EndLblName);

						Unindent();
						EmitRaw("# While END");
						break;
					}

				case Expr_BreakExpr BreakExpr:
					{
						string BreakLbl = State.PeekBreakLabel();
						EmitInstruction(FishInst.JUMP_LONG, BreakLbl);

						break;
					}

				case Expr_ContinueExpr ContinueExpr:
					{
						EmitRaw("# Continue");
						string BreakLbl = State.PeekLoopLabel();
						EmitInstruction(FishInst.JUMP_LONG, BreakLbl);

						break;
					}

				case Expr_AddressOfOp AddrOfExpr:
					{
						EmitRaw("# Expr_AddressOfOp BEGIN");
						Indent();

						if (AddrOfExpr.ValExpr is Expr_Identifier Ident)
						{
							EmitInstruction(FishInst.MOVE_LONG_REG, Ident.Identifier, Reg.EAX);
						}
						else
							throw new NotImplementedException();

						Unindent();
						EmitRaw("# Expr_AddressOfOp END");
						break;
					}

				case Expr_IndexOp IndexExpr:
					{
						EmitRaw("# IndexOp BEGIN");
						Indent();

						EmitRaw("#: EAX = {0}", IndexExpr.IndexValExpr.ToSourceStr());
						Compile(IndexExpr.IndexValExpr); // index in EAX

						if (IndexExpr.LExpr is Expr_Identifier id)
						{
							Expr_TypeDef idType = State.GetVarType(id.Identifier);
							int elemSize = State.GetPointerTypeSize(idType);

							EmitInstruction(FishInst.MOVE_REG_REG, Reg.EAX, Reg.EBX); // EBX = index

							if (elemSize > 1)
							{
								EmitRaw("#: EBX = EBX * {0}", elemSize);
								EmitInstruction(FishInst.MOVE_LONG_REG, "$" + elemSize, Reg.EAX);
								EmitInstruction(FishInst.MUL_REG, Reg.EBX);
								EmitInstruction(FishInst.MOVE_REG_REG, Reg.EAX, Reg.EBX); // EBX = scaled index
							}

							bool isUnsigned = CTType.IsUnsigned(idType.Type);

							EmitRaw("#: {0}[EBX]", id.Identifier);
							//Compile(IndexExpr.LExpr); // EAX = base pointer

							if (State.IndexEmitOnlyAddress)
							{
								FetchIdentifier(id.Identifier, 0, idType.IsPointer, Reg.EAX, true, true);
							}
							else
							{
								FetchIdentifier(id.Identifier, elemSize, idType.IsPointer, Reg.EAX, true, true);
							}


							//EmitInstruction(FishInst.ADD_REG_REG, Reg.EBX, Reg.EAX);

							/*int copyBytes = State.GetPointerTypeSize(idType);

							if (!State.IndexEmitOnlyAddress)
							{
								if (copyBytes == 1)
								{
									if (isUnsigned)
										EmitInstruction(FishInst.MOVEBYTE_OFFSET_REG_REG, 0, Reg.EAX, Reg.EAX);
									else
										EmitInstruction(FishInst.MOVES_OFFSET_REG_REG, 0, Reg.EAX, Reg.EAX);
								}
								else if (copyBytes == 2)
									EmitInstruction(FishInst.MOVEZ_OFFSET_REG_REG, 0, Reg.EAX, Reg.EAX);
								else if (copyBytes == 4)
									EmitInstruction(FishInst.MOVE_OFFSET_REG_REG, 0, Reg.EAX, Reg.EAX);
								else
									throw new NotImplementedException();
							}*/
						}
						else
						{
							EmitInstruction(FishInst.MOVE_REG_REG, Reg.EAX, Reg.EBX);
							Compile(IndexExpr.LExpr);
							EmitInstruction(FishInst.ADD_REG_REG, Reg.EBX, Reg.EAX);
						}

						Unindent();
						EmitRaw("# IndexOp END");
						break;
					}

				case Expr_IncDecOp IncDecExp:
					{
						EmitRaw("# Expr_IncDecOp BEGIN");
						Indent();

						if (IncDecExp.LExpr is Expr_Identifier Id)
						{
							string name = Id.Identifier;
							Expr_TypeDef nameType = State.GetVarType(name);
							int sz = 0;
							bool ispointer = nameType.IsPointer || nameType.IsArray;

							if (ispointer)
								sz = State.GetPointerTypeSize(nameType);
							else
								sz = State.GetTypeSize(nameType);

							FetchIdentifier(name, sz, ispointer, Reg.EAX, false, false);

							if (IncDecExp.Inc)
								EmitInstruction(FishInst.ADD_LONG_REG, "$" + 1, Reg.EAX);
							else
								EmitInstruction(FishInst.SUB_LONG_REG, "$" + 1, Reg.EAX);

							StoreIdentifier(name, sz, ispointer, Reg.EAX, false);
							/*if (State.IsVarGlobal(name))
							{
								// EAX = [global], modify, [global] = EAX
								EmitInstruction(FishInst.MOVE_LONG_REG, name, Reg.EBX);
								EmitInstruction(FishInst.MOVE_OFFSET_REG_REG, 0, Reg.EBX, Reg.EAX);

								if (IncDecExp.Inc)
									EmitInstruction(FishInst.ADD_LONG_REG, "$" + 1, Reg.EAX);
								else
									EmitInstruction(FishInst.SUB_LONG_REG, "$" + 1, Reg.EAX);

								EmitInstruction(FishInst.MOVE_REG_OFFSET_REG, Reg.EAX, 0, Reg.EBX);
							}
							else
							{
								int VarOffset = State.GetVarOffset(name);
								// EAX = [EBP+offset]
								EmitInstruction(FishInst.MOVE_OFFSET_REG_REG, VarOffset, Reg.EBP, Reg.EAX);

								if (IncDecExp.Inc)
									EmitInstruction(FishInst.ADD_LONG_REG, "$" + 1, Reg.EAX);
								else
									EmitInstruction(FishInst.SUB_LONG_REG, "$" + 1, Reg.EAX);

								EmitInstruction(FishInst.MOVE_REG_OFFSET_REG, Reg.EAX, VarOffset, Reg.EBP);
							}*/
						}
						else
							throw new NotImplementedException();

						Unindent();
						EmitRaw("# Expr_IncDecOp END");
						break;
					}

				case Expr_ReturnStatement ReturnExp:
					{
						EmitRaw("# Expr_ReturnStatement BEGIN");
						Indent();

						if (ReturnExp.RetValExpr != null)
						{
							Compile(ReturnExp.RetValExpr);
						}

						EmitReturn();

						Unindent();
						EmitRaw("# Expr_ReturnStatement END");
						break;
					}

				case Expr_FuncCall FuncCallExp:
					{
						if (FuncCallExp.Function.Identifier == "__asm")
						{
							foreach (var Arg in FuncCallExp.Arguments)
							{
								if (Arg is Expr_ConstString S)
								{
									EmitRaw(S.RawString);
								}
								else
								{
									throw new NotImplementedException("Only string literals are supported in __asm");
								}
							}
						}
						else if (FuncCallExp.Function.Identifier == "syscall_2")
						{
							EmitRaw("# syscall_2 BEGIN");
							Indent();

							if (FuncCallExp.Arguments.Count != 2)
								throw new Exception("syscall_2 requires exactly 2 arguments");

							Expr_ConstNumber NumExp = FuncCallExp.Arguments[0] as Expr_ConstNumber;
							Expression A0 = FuncCallExp.Arguments[1];

							Compile(A0);
							EmitInstruction(FishInst.PUSH_REG, Reg.EAX);
							EmitInstruction(FishInst.MOVE_LONG_REG, "$" + NumExp.NumberLiteral, Reg.EAX);
							EmitInstruction(FishInst.PUSH_REG, Reg.EAX);

							EmitInstruction(FishInst.SYSCALL_2);

							Unindent();
							EmitRaw("# syscall_2 END");
						}
						else
						{
							EmitRaw("# FuncCall BEGIN - {0}", FuncCallExp.Function.Identifier);
							Indent();

							for (int i = 0; i < FuncCallExp.Arguments.Count; i++)
							{
								Compile(FuncCallExp.Arguments[i]);
								EmitInstruction(FishInst.PUSH_REG, Reg.EAX);
							}

							EmitInstruction(FishInst.MOVE_LONG_REG, FuncCallExp.Function.Identifier, Reg.EAX);
							EmitInstruction(FishInst.CALL_REG, Reg.EAX);

							EmitInstruction(FishInst.ADD_LONG_REG, (uint)(FuncCallExp.Arguments.Count * 4), Reg.ESP);

							Unindent();
							EmitRaw("# FuncCall END - {0}", FuncCallExp.Function.Identifier);
						}

						break;
					}

				default:
					{
						throw new NotImplementedException("Could not compile expression of type " + Ex.GetType());
					}
			}
		}
	}
}